// Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

'use strict'

const assert = require('assert')

const AWS = require('aws-sdk')

const { getAllUsagePlans } = require('dev-portal-common/get-all-usage-plans')
const { getEnv } = require('dev-portal-common/get-env')
// const { inspectStringify } = require('dev-portal-common/inspect-stringify')
const pager = require('dev-portal-common/pager')
const { getCognitoUserSub } = require('dev-portal-common/get-cognito-user-sub')
const { promisify2 } = require('dev-portal-common/promisify2')

const dynamoDb = new AWS.DynamoDB.DocumentClient()
const apigateway = new AWS.APIGateway()
const cognitoIdp = new AWS.CognitoIdentityServiceProvider()

function getCustomersTableName () {
  return getEnv('CustomersTableName', 'DevPortalCustomers')
}

/**
 * Ensure user is tracked in customer table, and pop item from
 * PreLoginAccountsTable if present (transferring its fields to the customer
 * table item).
 *
 * Note to future maintainers: This function contains old code which may be
 * over-engineered.
 */
async function ensureCustomerItem (
  cognitoIdentityId,
  cognitoUserId,
  keyId,
  errorCallback,
  successCallback
) {
  let customerItem
  let preLoginItem
  try {
    const customerPromise = dynamoDb
      .get({
        TableName: getCustomersTableName(),
        Key: {
          Id: cognitoIdentityId
        }
      })
      .promise()
    const preLoginAccountPromise = dynamoDb
      .get({
        TableName: getEnv('PreLoginAccountsTableName'),
        Key: {
          UserId: cognitoUserId
        }
      })
      .promise()

    const [customerResponse, preLoginAccountResponse] = await Promise.all([
      customerPromise,
      preLoginAccountPromise
    ])

    customerItem = customerResponse.Item
    preLoginItem = preLoginAccountResponse.Item
  } catch (error) {
    console.error(error)
    errorCallback(error)
    return
  }

  // We assume that if customerItem is defined (i.e. present in
  // CustomersTable), then the following are true:
  //  - the item was migrated from pre-account management, or has logged in
  //    since signing up (and thus contains any relevant data that was
  //    previously or currently stored in PreLoginAccountsTable)
  //  - the customerItem's RegistrationStatus, Id (identity ID), UserPoolId
  //    (user ID), and ApiKeyId are all present
  if (customerItem !== undefined) {
    console.log(
      `Found CustomersTable item with identity ID [${cognitoIdentityId}]`
    )

    if (successCallback) {
      successCallback(customerItem)
      return
    } else {
      return customerItem
    }
  }

  if (preLoginItem === undefined) {
    const errorMessage =
      'Account not found in CustomersTable or PreLoginAccountsTable!'
    console.error(errorMessage)
    errorCallback(new Error(errorMessage))
  }

  let newCustomerItem
  try {
    newCustomerItem = await transferPreLoginAccountToCustomersTable({
      identityId: cognitoIdentityId,
      apiKeyId: keyId,
      preLoginItem
    })
    console.log(
      `Created new customer in CustomersTable with identity ID [${newCustomerItem.Id}]`
    )
  } catch (error) {
    console.error(error)
    errorCallback(error)
    return
  }

  if (successCallback) {
    successCallback(newCustomerItem)
  } else {
    return newCustomerItem
  }
}

function getCognitoIdentityId (marketplaceCustomerId, error, callback) {
  const params = {
    TableName: getCustomersTableName(),
    IndexName: 'MarketplaceCustomerIdIndex',
    KeyConditionExpression: 'MarketplaceCustomerId = :customerId',
    ExpressionAttributeValues: {
      ':customerId': marketplaceCustomerId
    },
    ProjectionExpression: 'MarketplaceCustomerId, Id'
  }
  dynamoDb.query(params, (err, data) => {
    if (err) {
      error(err)
    } else if (data.Items === undefined || data.Items.length === 0) {
      // no customer matching marketplaceCustomerId - this should be created during marketplace subscription redirect
      error(`No customer is registered in the developer portal for marketplace customer ID ${marketplaceCustomerId}`)
    } else {
      callback(data.Items[0].Id)
    }
  })
}

function subscribe (cognitoIdentityId, usagePlanId, errFunc, callback) {
  getApiKeyForCustomer(cognitoIdentityId, errFunc, data => {
    console.log(`Get Api Key data ${JSON.stringify(data)}`)

    if (data.items.length === 0) {
      console.log(`No API Key found for customer ${cognitoIdentityId}`)

      createApiKey(cognitoIdentityId, errFunc, createData => {
        console.log(`Create API Key data: ${createData}`)
        const keyId = createData.id

        console.log(`Got key ID ${keyId}`)

        createUsagePlanKey(keyId, usagePlanId, errFunc, createKeyData => {
          callback(createKeyData)
        })
      })
    } else {
      const keyId = data.items[0].id

      console.log(`Got key ID ${keyId}`)

      createUsagePlanKey(keyId, usagePlanId, errFunc, createKeyData => {
        callback(createKeyData)
      })
    }
  })
}

function unsubscribe (cognitoIdentityId, usagePlanId, error, success) {
  getApiKeyForCustomer(cognitoIdentityId, error, data => {
    console.log(`Get Api Key data ${JSON.stringify(data)}`)

    if (data.items.length === 0) {
      console.log(`No API Key found for customer ${cognitoIdentityId}`)

      error('Customer does not have an API Key')
    } else {
      const keyId = data.items[0].id

      console.log(`Found API Key for customer with ID ${keyId}`)

      deleteUsagePlanKey(keyId, usagePlanId, error, deleteData => {
        success(deleteData)
      })
    }
  })
}

/**
 * Creates and returns an API key for the given identityId and userId.
 */
async function __createApiKey ({ identityId, userId, enabled }) {
  console.log(`Creating API Key for identity ID [${identityId}]`)

  let apiKey
  try {
    apiKey = await apigateway
      .createApiKey({
        description: `Dev Portal API Key for account with Identity Pool user ${identityId} / User Pool user ${userId}`,
        enabled,
        generateDistinctId: true,
        // set the name to the cognito identity ID so we can query API Key by the
        // cognito identity
        name: `${identityId}/${userId}`
      })
      .promise()
  } catch (error) {
    console.error('Failed to create API key:', error)
    throw error
  }
  console.log(`Created API key with ID [${apiKey.id}]`)

  await promisify2(updateCustomerApiKeyId)(identityId, apiKey.id)
  return apiKey
}

function createApiKey (cognitoIdentityId, cognitoUserId, error, callback) {
  isCognitoUserInGroup({
    userId: cognitoUserId,
    groupName: getEnv('RegisteredGroupName')
  })
    .then(isRegistered =>
      __createApiKey({
        identityId: cognitoIdentityId,
        userId: cognitoUserId,
        enabled: isRegistered
      })
    )
    .then(apiKeyData => {
      callback(apiKeyData)
    })
    .catch(error => {
      error(error)
    })
}

function createUsagePlanKey (keyId, usagePlanId, error, callback) {
  console.log(
    `Creating usage plan key for key id ${keyId} and usagePlanId ${usagePlanId}`
  )

  const params = {
    keyId,
    keyType: 'API_KEY',
    usagePlanId
  }
  apigateway.createUsagePlanKey(params, (err, data) => {
    if (err) error(err)
    else callback(data)
  })
}

function deleteUsagePlanKey (keyId, usagePlanId, error, callback) {
  console.log(
    `Deleting usage plan key for key id ${keyId} and usagePlanId ${usagePlanId}`
  )

  const params = {
    keyId,
    usagePlanId
  }
  apigateway.deleteUsagePlanKey(params, (err, data) => {
    if (err) error(err)
    else callback(data)
  })
}
/* eslint-enable standard/no-callback-literal */

function getApiKeyForCustomer (cognitoIdentityId, error, callback) {
  console.log(`Getting API Key for customer  ${cognitoIdentityId}`)

  const params = {
    limit: 1,
    includeValues: true,
    nameQuery: cognitoIdentityId
  }
  apigateway.getApiKeys(params, (err, data) => {
    if (err) error(err)
    else callback(data)
  })
}

const updateApiKeyEnabled = async ({ apiKeyId, enabled }) => {
  console.log(
    `Updating API key with apiKeyId=[${apiKeyId}] to set enabled=${enabled}`
  )
  const updateResult = await apigateway
    .updateApiKey({
      apiKey: apiKeyId,
      patchOperations: [
        { op: 'replace', path: '/enabled', value: `${enabled}` }
      ]
    })
    .promise()
  assert(updateResult.enabled === enabled)
  console.log('Updated API key')
  return updateResult
}

/**
 * Create or update an API key for the given Cognito userId and identityId,
 * which is enabled iff the customer's account is in the RegisteredGroup.
 */
const ensureApiKeyForCustomer = async ({ userId, identityId }) => {
  console.log(`Ensuring API key for customer with userId=[${userId}]`)
  let updatedApiKey

  try {
    const [existingApiKeys, isRegistered] = await Promise.all([
      apigateway
        .getApiKeys({
          nameQuery: identityId,
          limit: 1
        })
        .promise(),
      isCognitoUserInGroup({
        userId,
        groupName: getEnv('RegisteredGroupName')
      })
    ])
    const existingApiKey = existingApiKeys.items[0]
    if (existingApiKey && existingApiKey.enabled !== isRegistered) {
      console.log(
        `Found API key with enabled=${existingApiKey.enabled}` +
        ` but isRegistered=${isRegistered}`
      )
      updatedApiKey = await updateApiKeyEnabled({
        apiKeyId: existingApiKey.id,
        enabled: isRegistered
      })
    } else if (existingApiKey === undefined) {
      console.log(`No API key found; creating one with enabled=${isRegistered}`)
      updatedApiKey = await __createApiKey({
        identityId,
        userId,
        enabled: isRegistered
      })
    } else {
      console.log(
        `Found API key with isRegistered = enabled = ${existingApiKey.enabled}`
      )
      updatedApiKey = existingApiKey
    }
  } catch (error) {
    console.error('Failed to ensure API key:', error)
    throw error
  }
  console.log('Ensured API key for customer')
  return updatedApiKey
}

function getUsagePlansForCustomer (cognitoIdentityId, error, callback) {
  console.log(`Getting API Key for customer ${cognitoIdentityId}`)

  getApiKeyForCustomer(cognitoIdentityId, error, data => {
    if (data.items.length === 0) {
      // eslint-disable-next-line standard/no-callback-literal
      callback({ data: {} })
    } else {
      const keyId = data.items[0].id
      const params = {
        keyId,
        limit: 1000
      }
      getAllUsagePlans(apigateway, params)
        // eslint-disable-next-line standard/no-callback-literal
        .then(usagePlansData => callback({ items: usagePlansData }))
        .catch(err => error(err))
    }
  })
}

function getUsagePlanForProductCode (productCode, error, callback) {
  console.log(`Getting Usage Plan for product ${productCode}`)

  // do a linear scan of usage plans for name matching productCode
  var params = {
    limit: 1000
  }
  getAllUsagePlans(apigateway, params)
    .then(usagePlans => {
      console.log(`Got usage plans ${JSON.stringify(usagePlans)}`)

      // note: ensure that only one usage plan maps to a given marketplace product code
      const usageplan = usagePlans.find(function (item) {
        return (
          item.productCode !== undefined && item.productCode === productCode
        )
      })
      if (usageplan !== undefined) {
        console.log(`Found usage plan matching ${productCode}`)
        callback(usageplan)
      } else {
        console.log(
          `Couldn't find usageplan matching product code ${productCode}`
        )
        error(`Couldn't find usageplan matching product code ${productCode}`)
      }
    })
    .catch(err => error(err))
}

function updateCustomerMarketplaceId (
  cognitoIdentityId,
  marketplaceCustomerId,
  error,
  success
) {
  const dynamoDbParams = {
    TableName: getCustomersTableName(),
    Key: {
      Id: cognitoIdentityId
    },
    UpdateExpression: 'set #a = :x',
    ExpressionAttributeNames: { '#a': 'MarketplaceCustomerId' },
    ExpressionAttributeValues: {
      ':x': marketplaceCustomerId
    }
  }

  // update DDB customer record with marketplace customer id
  // and update API Gateway API Key with marketplace customer id
  dynamoDb.update(dynamoDbParams, dynamoDbErr => {
    if (dynamoDbErr) {
      error(dynamoDbErr)
    } else {
      getApiKeyForCustomer(cognitoIdentityId, error, data => {
        console.log(`Get Api Key data ${JSON.stringify(data)}`)

        if (data.items.length === 0) {
          console.log(`No API Key found for customer ${cognitoIdentityId}`)

          createApiKey(cognitoIdentityId, error, createData => {
            console.log(`Create API Key data: ${createData}`)
            const keyId = createData.id

            console.log(`Got key ID ${keyId}`)

            updateApiKey(keyId, marketplaceCustomerId, error, createKeyData => {
              success(createKeyData)
            })
          })
        } else {
          const keyId = data.items[0].id

          console.log(`Got key ID ${keyId}`)

          updateApiKey(keyId, marketplaceCustomerId, error, createKeyData => {
            success(createKeyData)
          })
        }
      })
    }
  })
}

function updateApiKey (apiKeyId, marketplaceCustomerId, error, success) {
  console.log(
    `Updating API Key ${apiKeyId} in API Gateway with marketplace customer ID`
  )

  // update API Gateway API Key with marketplace customer id to support metering
  var params = {
    apiKey: apiKeyId,
    patchOperations: [
      {
        op: 'replace',
        path: '/customerId',
        value: marketplaceCustomerId
      }
    ]
  }
  apigateway.updateApiKey(params, function (err, data) {
    if (err) error(err)
    else success(data)
  })
}

/**
 * Updates the account's `ApiKey` column in the CustomersTable.
 *
 * Precondition: the corresponding CustomersTable item must already exist.
 */
function updateCustomerApiKeyId (cognitoIdentityId, apiKeyId, error, success) {
  console.log(`Updating API Key for identity ID [${cognitoIdentityId}]`)

  // update customer record with marketplace customer code
  const dynamoDbParams = {
    TableName: getCustomersTableName(),
    Key: {
      Id: cognitoIdentityId
    },
    UpdateExpression: 'set #a = :x',
    ExpressionAttributeNames: { '#a': 'ApiKeyId' },
    ExpressionAttributeValues: {
      ':x': apiKeyId
    }
  }

  dynamoDb.update(dynamoDbParams, dynamoDbErr => {
    if (dynamoDbErr) {
      console.error('Failed to updated API Key:', dynamoDbErr)
      error(dynamoDbErr)
    } else {
      console.log(`Updated API Key for identity ID [${cognitoIdentityId}]`)
      success()
    }
  })
}

const addAccountToRegisteredGroup = async ({
  username,
  userPoolId,
  registeredGroupName
}) => {
  console.log(`Adding account username=[${username}] to RegisteredGroup`)

  try {
    await cognitoIdp
      .adminAddUserToGroup({
        GroupName: registeredGroupName,
        UserPoolId: userPoolId,
        Username: username
      })
      .promise()
  } catch (error) {
    console.error(
      `Failed to add account username=[${username}] to RegisteredGroup:`,
      error
    )
    throw error
  }
}

/**
 * Creates an item in the PreLoginAccountsTable for the given `preLoginItem`'s
 * `UserId`.
 */
const __savePreLoginAccount = async preLoginItem => {
  console.log(
    'Saving pre-login account data:',
    JSON.stringify(preLoginItem, null, 2)
  )

  try {
    await dynamoDb
      .put({
        TableName: getEnv('PreLoginAccountsTableName'),
        Item: preLoginItem,
        ConditionExpression: 'attribute_not_exists(UserId)'
      })
      .promise()
  } catch (error) {
    console.error(
      'Failed to add save pre-login account data for' +
      ` userId=[${preLoginItem.UserId}]:`,
      error
    )
    throw error
  }
  return preLoginItem
}

const getCurrentTimestamp = () => new Date().toISOString()

const saveOpenPreLoginAccount = ({ userId, emailAddress }) =>
  __savePreLoginAccount({
    UserId: userId,
    // For open-mode registrations, Cognito will set the username as the userId
    // (`cognito:sub`)
    Username: userId,
    EmailAddress: emailAddress,
    DateRegistered: getCurrentTimestamp(),
    RegistrationMethod: 'open',
    RegistrationStatus: 'registered'
  })

const saveRequestPreLoginAccount = ({ userId, emailAddress }) =>
  __savePreLoginAccount({
    UserId: userId,
    // For request-mode registrations, Cognito will set the username as the
    // userId (`cognito:sub`)
    Username: userId,
    EmailAddress: emailAddress,
    DateRequested: getCurrentTimestamp(),
    RegistrationMethod: 'request',
    RegistrationStatus: 'pendingRequest'
  })

const saveInvitePreLoginAccount = ({
  userId,
  username,
  emailAddress,
  inviterUserId,
  inviterEmailAddress
}) =>
  __savePreLoginAccount({
    UserId: userId,
    Username: username,
    EmailAddress: emailAddress,
    DateInvited: getCurrentTimestamp(),
    RegistrationMethod: 'invite',
    RegistrationStatus: 'pendingInvite',
    InviterUserId: inviterUserId,
    InviterEmailAddress: inviterEmailAddress
  })

/**
 * Given an account item from the PreLoginAccountsTable, transfer the data to
 * the CustomersTable, and (if successful) delete the item from the
 * PreLoginAccountsTable.
 */
const transferPreLoginAccountToCustomersTable = async ({
  identityId,
  apiKeyId,
  preLoginItem
}) => {
  console.log(
    'Transferring pre-login account data to customers table' +
    ` for identityId=[${identityId}]`
  )

  const newCustomerItem = {
    ApiKeyId: apiKeyId,
    Id: identityId,
    UserPoolId: preLoginItem.UserId
  }

  ;[
    'EmailAddress',
    'RegistrationStatus',
    'RegistrationMethod',
    'InviterUserId',
    'InviterEmailAddress',
    'PromoterIdentityId',
    'PromoterEmailAddress',
    'DateRegistered',
    'DateRequested'
  ].forEach(prop => {
    if ({}.hasOwnProperty.call(preLoginItem, prop)) {
      newCustomerItem[prop] = preLoginItem[prop]
    }
  })

  try {
    await dynamoDb
      .put({
        TableName: getCustomersTableName(),
        Item: newCustomerItem
      })
      .promise()

    // This must only occur if `newCustomerItem` is successfully written to
    // CustomersTable, because otherwise the `preLoginItem` data is
    // unrecoverable.
    if (preLoginItem !== undefined) {
      await dynamoDb
        .delete({
          TableName: getEnv('PreLoginAccountsTableName'),
          Key: {
            UserId: preLoginItem.UserId
          }
        })
        .promise()
    }
    console.log('Transferred pre-login account data to customers table')
  } catch (error) {
    console.error(
      'Failed to transfer pre-login account data to customers table'
    )
    throw error
  }

  return newCustomerItem
}

/**
 * Fetches and returns account items with the given `registrationStatus`.
 */
const listAccountsByRegistrationStatus = async registrationStatus => {
  console.log(
    `Listing accounts with registrationStatus [${registrationStatus}]`
  )

  try {
    const filterParams = {
      FilterExpression: 'RegistrationStatus = :status',
      ExpressionAttributeValues: {
        ':status': registrationStatus
      }
    }
    const accounts = await fetchAllDdbAccounts({
      preLoginAccountsTableExtraParams: filterParams,
      customersTableExtraParams: filterParams
    })
    console.log(`Query returned ${accounts.length} accounts`)
    return accounts
  } catch (error) {
    console.error('Failed to list accounts:', error)
    throw error
  }
}

/**
 * Fetches and returns (normalized) account items from both the CustomersTable
 * and the PreLoginAccountsTable.
 */
const fetchAllDdbAccounts = async ({
  customersTableExtraParams,
  preLoginAccountsTableExtraParams
}) => {
  const [
    unnormalizedCustomersTableAccounts,
    preLoginAccounts
  ] = await Promise.all([
    pager.fetchItemsInDynamoDbTable({
      dynamoDbClient: exports.dynamoDb,
      tableName: getCustomersTableName(),
      extraParams: customersTableExtraParams
    }),
    pager.fetchItemsInDynamoDbTable({
      dynamoDbClient: exports.dynamoDb,
      tableName: getEnv('PreLoginAccountsTableName'),
      extraParams: preLoginAccountsTableExtraParams
    })
  ])
  const customerAccounts = unnormalizedCustomersTableAccounts.map(
    normalizeCustomersTableAccount
  )

  // Check uniqueness by UserId since it exists on all items in both tables,
  // unlike IdentityId. Take CustomersTable items over PreLoginAccountsTable
  // items when both exist.
  const uniqueAccounts = new Map()
  const addAccount = account => uniqueAccounts.set(account.UserId, account)
  preLoginAccounts.forEach(addAccount)
  customerAccounts.forEach(addAccount)
  return [...uniqueAccounts.values()]
}

/**
 * "Normalizes" an account item from CustomersTable, by renaming the "Id"
 * attribute to "IdentityId" and renaming the "UserPoolId" attribute to
 * "UserId". This makes it consistent with the more intuitive attribute names
 * in the PreLoginAccountsTable.
 */
const normalizeCustomersTableAccount = account => {
  const { Id: IdentityId, UserPoolId: UserId, ...rest } = account
  return { IdentityId, UserId, ...rest }
}

const denormalizeCustomersTableAccount = account => {
  const { IdentityId: Id, UserId: UserPoolId, ...rest } = account
  return { Id, UserPoolId, ...rest }
}

const listRegisteredAccounts = () =>
  listAccountsByRegistrationStatus('registered')

const listPendingRequestAccounts = () =>
  listAccountsByRegistrationStatus('pendingRequest')

const listPendingInviteAccounts = () =>
  listAccountsByRegistrationStatus('pendingInvite')

const listAdminAccounts = async () => {
  console.log('Listing admin accounts')

  const adminGroupUsersPromise = pager.fetchUsersInCognitoUserPoolGroup({
    cognitoClient: exports.cognitoIdp,
    userPoolId: getEnv('UserPoolId'),
    groupName: getEnv('AdminsGroupName')
  })
  const allDdbAccountItemsPromise = fetchAllDdbAccounts({
    preLoginAccountsTableExtraParams: {},
    customersTableExtraParams: {}
  })
  const [adminGroupUsers, allDdbAccountItems] = await Promise.all([
    adminGroupUsersPromise,
    allDdbAccountItemsPromise
  ])
  console.info(`Found ${adminGroupUsers.length} AdminsGroup Cognito users`)
  console.info(`Found ${allDdbAccountItems.length} accounts in DDB`)

  const adminGroupUserIds = new Set(adminGroupUsers.map(getCognitoUserSub))
  const adminAccounts = allDdbAccountItems.filter(({ UserId }) =>
    adminGroupUserIds.has(UserId)
  )
  console.info(
    `Found ${adminAccounts.length} DDB accounts` +
    ' with matching AdminsGroup Cognito users'
  )
  return adminAccounts
}

const approveAccountPendingRequest = async userId => {
  console.log(`Approving pending account request for userId=[${userId}]`)
  const { account, source } = await findAccountByUserId(userId)
  if (account === null) {
    throw new Error('Account not found')
  }
  if (account.RegistrationStatus !== 'pendingRequest') {
    throw new Error(
      'Cannot approve account with' +
      ` RegistrationStatus=[${account.RegistrationStatus}]`
    )
  }

  await exports.addAccountToRegisteredGroup({
    // Cognito sets username equal to `sub` (userId)
    username: userId,
    userPoolId: getEnv('UserPoolId'),
    registeredGroupName: getEnv('RegisteredGroupName')
  })

  // Only update DDB if the above succeeds, or else the user cannot assume the
  // Registered role.
  account.RegistrationStatus = 'registered'
  account.DateRegistered = getCurrentTimestamp()
  await updateAccountFromSource({ account, source })
}

const denyAccountPendingRequest = async userId => {
  console.log(`Denying pending account request for userId=[${userId}]`)
  await deleteAccountByUserId(userId)
  console.log('Denied pending account request')
}

const findCustomersTableAccountByUserId = async userId => {
  console.log(`Finding account with userId=[${userId}] in CustomersTable`)
  const customersTableItems = await pager.fetchItemsInDynamoDbTable({
    dynamoDbClient: exports.dynamoDb,
    tableName: getCustomersTableName(),
    extraParams: {
      FilterExpression: 'UserPoolId = :userId',
      ExpressionAttributeValues: { ':userId': userId }
    }
  })
  if (customersTableItems.length > 0) {
    console.log('Found account')
    return normalizeCustomersTableAccount(customersTableItems[0])
  }

  console.log('No account found')
  return null
}

const findAccountByUserId = async userId => {
  console.log(`Finding account with userId=[${userId}]`)

  console.log('Searching in PreLoginAccountsTable')
  const preLoginItem = await exports.dynamoDb
    .get({
      TableName: getEnv('PreLoginAccountsTableName'),
      Key: { UserId: userId }
    })
    .promise()
  if (preLoginItem.Item) {
    console.log('Found account in PreLoginAccountsTable')
    return {
      account: preLoginItem.Item,
      source: 'PreLoginAccountsTable'
    }
  }

  console.log('Searching in CustomersTable')
  const customersTableItem = await findCustomersTableAccountByUserId(userId)
  if (customersTableItem) {
    return {
      account: customersTableItem,
      source: 'CustomersTable'
    }
  }

  console.log('Account not found')
  return { account: null }
}

const updateAccountFromSource = async ({ account, source }) => {
  if (source === 'CustomersTable') {
    return __updateAccountInCustomersTable(account)
  }
  if (source === 'PreLoginAccountsTable') {
    return __updateAccountInPreLoginAccountsTable(account)
  }
  throw new Error(`Invalid account source [${source}]`)
}

const __updateAccountInCustomersTable = async account => {
  console.log(
    `Updating account with userId=[${account.UserId}] in CustomersTable`
  )
  const result = await exports.dynamoDb
    .put({
      TableName: getCustomersTableName(),
      Item: denormalizeCustomersTableAccount(account),
      ConditionExpression: 'attribute_exists(Id)'
    })
    .promise()
  console.log('Successfully updated account')
  return result
}

const __updateAccountInPreLoginAccountsTable = async account => {
  console.log(
    `Updating account with userId=[${account.UserId}] in PreLoginAccountsTable`
  )
  const result = await exports.dynamoDb
    .put({
      TableName: getEnv('PreLoginAccountsTableName'),
      Item: account,
      ConditionExpression: 'attribute_exists(UserId)'
    })
    .promise()
  console.log('Successfully updated account')
  return result
}

const deleteAccountFromCustomersTable = async identityId => {
  console.log(
    `Deleting account with identityId=[${identityId}] from CustomersTable`
  )
  try {
    await dynamoDb
      .delete({
        TableName: getCustomersTableName(),
        Key: { Id: identityId }
      })
      .promise()
  } catch (error) {
    console.error('Failed to delete account:', error)
    throw error
  }
  console.log(
    `Deleted account with identityId=[${identityId}] from CustomersTable`
  )
}

const deleteAccountFromPreLoginTable = async userId => {
  console.log(
    `Deleting account with userId=[${userId}] from PreLoginAccountsTable`
  )
  try {
    await dynamoDb
      .delete({
        TableName: getEnv('PreLoginAccountsTableName'),
        Key: { UserId: userId }
      })
      .promise()
  } catch (error) {
    console.error('Failed to delete account:', error)
    throw error
  }
  console.log(
    `Deleted account with userId=[${userId}] from PreLoginAccountsTable`
  )
}

const deleteUserFromUserPool = async userId => {
  console.log(`Deleting user with userId=[${userId}] from user pool`)
  try {
    await cognitoIdp
      .adminDeleteUser({
        UserPoolId: getEnv('UserPoolId'),
        Username: userId
      })
      .promise()
  } catch (error) {
    console.error('Failed to delete account:', error)
    throw error
  }
  console.log(`Deleted user with userId=[${userId}] from user pool`)
}

const deleteAccountByUserId = async userId => {
  console.log(`Deleting all items for account with userId=[${userId}]`)

  // Assume there are no API keys to delete
  let deleteApiKeysPromise = Promise.resolve()

  // If identityId exists, then there may be keys to delete
  const { account, source } = await findAccountByUserId(userId)
  if (!account) {
    console.warn('No account found! So no API keys will be deleted')
  } else if (source === 'CustomersTable') {
    assert(!!account.IdentityId)
    deleteApiKeysPromise = deleteApiKeysByIdentityId(account.IdentityId)
  }

  const deleteFromPreLoginTablePromise = deleteAccountFromPreLoginTable(userId)

  const deleteAccountFromCustomersTablePromise = (async () => {
    const customersTableAccount = await findCustomersTableAccountByUserId(
      userId
    )
    if (customersTableAccount !== null) {
      await deleteAccountFromCustomersTable(customersTableAccount.IdentityId)
    }
  })()

  const deleteUserFromUserPoolPromise = deleteUserFromUserPool(userId)

  await Promise.all([
    deleteFromPreLoginTablePromise,
    deleteAccountFromCustomersTablePromise,
    deleteUserFromUserPoolPromise,
    deleteApiKeysPromise
  ])
  console.log(`Deleted all items for account with userId=[${userId}]`)
}

const deleteApiKeysByIdentityId = async identityId => {
  console.log(
    `Deleting all API keys for account with identityId=[${identityId}]`
  )

  try {
    const allApiKeys = await pager.fetchApiGatewayApiKeys({
      apiGatewayClient: apigateway,
      identityId
    })
    console.log(`Found ${allApiKeys.length} API keys to delete`)
    await Promise.all(
      allApiKeys.map(apiKey =>
        apigateway.deleteApiKey({ apiKey: apiKey.id }).promise()
      )
    )
  } catch (error) {
    console.error('Failed to delete API keys:', error)
    throw error
  }

  console.log(
    `Deleted all API keys for account with identityId=[${identityId}]`
  )
}

const getEmailForUserSub = async userSub => {
  const found = await cognitoIdp
    .listUsers({
      Filter: `sub = "${userSub}"`,
      Limit: 1,
      AttributesToGet: ['email'],
      UserPoolId: getEnv('UserPoolId')
    })
    .promise()

  return found.Users[0].Attributes[0].Value
}

async function __isUserAnAdmin (targetUserId) {
  const result = await cognitoIdp
    .adminListGroupsForUser({
      Username: targetUserId,
      UserPoolId: getEnv('UserPoolId')
    })
    .promise()

  return result.Groups.some(g => g.GroupName === getEnv('AdminsGroupName'))
}

const __recordPromotionInDdb = async ({
  targetUserId,
  promoterUserId,
  promoterEmailAddress
}) => {
  console.log(
    `Recording promotion of targetUserId=[${targetUserId}]` +
    ` by promoterEmailAddress=[${promoterUserId}] in DDB`
  )
  const { account: targetAccount, source } = await findAccountByUserId(
    targetUserId
  )
  if (targetAccount === null) {
    throw new Error('Target user not found!')
  }
  targetAccount.PromoterUserId = promoterUserId
  targetAccount.PromoterEmailAddress = promoterEmailAddress
  targetAccount.DatePromoted = new Date().toISOString()
  await updateAccountFromSource({ account: targetAccount, source })
  console.log('Recorded promotion')
}

const addAccountToAdminsGroup = async ({ targetUserId, promoterUserSub, promoterUserId }) => {
  console.log(`Checking if account with userId=[${targetUserId}] is in AdminsGroup`)

  if (await __isUserAnAdmin(targetUserId)) {
    console.log(`Account with userId=[${targetUserId}] is in AdminsGroup, skipping`)
    return
  }

  console.log(`Adding account with userId=[${targetUserId}] to AdminsGroup`)

  await Promise.all([
    getEmailForUserSub(promoterUserSub).then(promoterEmailAddress =>
      __recordPromotionInDdb({
        targetUserId,
        promoterUserId,
        promoterEmailAddress
      })
    ),
    cognitoIdp
      .adminAddUserToGroup({
        GroupName: getEnv('AdminsGroupName'),
        UserPoolId: getEnv('UserPoolId'),
        Username: targetUserId
      })
      .promise()
  ])

  console.log('Added account to AdminsGroup')
}

const createAccountInvite = async ({ targetEmailAddress, inviterUserSub, inviterUserId }) => {
  console.log(`Creating invite for targetEmailAddress=[${targetEmailAddress}]`)

  console.log('Finding inviter user details')
  const inviterEmailAddress = await getEmailForUserSub(inviterUserSub)

  console.log('Creating Cognito user')
  const createUserResponse = await cognitoIdp
    .adminCreateUser({
      UserPoolId: getEnv('UserPoolId'),
      Username: targetEmailAddress
    })
    .promise()
  const targetUser = createUserResponse.User

  console.log('Saving invite pre-login account')
  const preLoginAccount = await saveInvitePreLoginAccount({
    userId: getCognitoUserSub(targetUser),
    username: targetUser.Username,
    emailAddress: targetEmailAddress,
    inviterUserId,
    inviterEmailAddress
  })

  console.log('Created invite')
  return preLoginAccount
}

const resendAccountInvite = async ({ targetEmailAddress }) => {
  console.log(`Resending invite for targetEmailAddress=[${targetEmailAddress}]`)
  try {
    await cognitoIdp
      .adminCreateUser({
        UserPoolId: getEnv('UserPoolId'),
        Username: targetEmailAddress,
        MessageAction: 'RESEND'
      })
      .promise()
  } catch (error) {
    console.error('Failed to resend invite:', error)
    throw error
  }
  console.log('Resent invite')
}

const isCognitoUserInGroup = async ({ userId, groupName }) => {
  const userGroups = await pager.fetchGroupsForCognitoUser({
    cognitoClient: cognitoIdp,
    username: userId,
    userPoolId: getEnv('UserPoolId')
  })
  return userGroups.some(({ GroupName }) => GroupName === groupName)
}

exports = module.exports = {
  ensureCustomerItem,
  subscribe,
  unsubscribe,
  createApiKey,
  createUsagePlanKey,
  deleteUsagePlanKey,
  getApiKeyForCustomer,
  getUsagePlansForCustomer,
  getUsagePlanForProductCode,
  updateCustomerMarketplaceId,
  getCognitoIdentityId,
  dynamoDb,
  cognitoIdp,
  addAccountToRegisteredGroup,
  saveOpenPreLoginAccount,
  saveRequestPreLoginAccount,
  saveInvitePreLoginAccount,
  listPendingRequestAccounts,
  listPendingInviteAccounts,
  listAdminAccounts,
  listRegisteredAccounts,
  approveAccountPendingRequest,
  denyAccountPendingRequest,
  deleteAccountByUserId,
  addAccountToAdminsGroup,
  createAccountInvite,
  resendAccountInvite,
  findAccountByUserId,
  updateAccountFromSource,
  ensureApiKeyForCustomer
}
